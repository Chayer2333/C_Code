# *C17 与 C99 标准核心差异说明*

## 概述

C17（正式名称为 ISO/IEC 9899:2018）与 C99（ISO/IEC 9899:1999）之间存在显著差异。\
关键点是：**C17 本身并非引入新特性的标准，它本质上是 C11（2011年）的“缺陷修复版”**。\
因此，从 C99 到 C17 的演进，其主要变化由 C11 完成。

## 核心差异对比表

| 特性维度 | C99 (ISO/IEC 9899:1999) | C17 / C11 (ISO/IEC 9899:2018/2011) | 核心变化与说明 |
| :--- | :--- | :--- | :--- |
| **版本定位** | 重大功能扩充版本。 | C11是主要更新；C17是C11的缺陷修复版。 | C17未增加新功能，仅修正C11的缺陷。 |
| **新数据类型** | 引入 `long long int`、`_Bool`、复数类型及**变长数组(VLA)**。 | 继承C99类型，但将**变长数组(VLA)改为可选**。 | C11中，编译器可定义 `__STDC_NO_VLA__` 宏表明不支持VLA。 |
| **多线程支持** | 无标准线程支持。 | 引入 **`<threads.h>` 标准库**。 | 提供线程、互斥锁、条件变量的标准API。 |
| **安全性增强** | 无。 | 引入**边界检查函数**和 **_Static_assert** 关键字。 | 旨在减少缓冲区溢出风险；支持编译时断言。 |
| **语法与泛型** | 允许混合声明与代码、支持 `//` 注释。 | 新增 **_Generic 泛型选择**。 | 根据表达式类型在编译时选择不同代码分支。 |
| **Unicode支持** | 支持宽字符(`wchar_t`)。 | 引入 **`char16_t` 和 `char32_t`** 类型及对应字面量。 | 提供对UTF-16/32的更直接支持。 |
| **对齐操作** | 无标准方式。 | 引入 **_Alignas`、`_Alignof` 关键字及 `<stdalign.h>`**。 | 提供标准的对齐控制和查询方式。 |
| **匿名结构与联合** | 不支持。 | **支持匿名结构和匿名联合**。 | 允许在嵌套时直接访问成员，简化数据结构。 |
| **快速退出** | 仅 `exit()`。 | 新增 **`<stdnoreturn.h>` 和 `_Noreturn`**。 | 明确标识从不返回的函数。 |

## 编译器支持与检测

### 1. 编译器支持与指定
- **GCC, Clang**: 通过命令行选项指定，如 `-std=c99`, `-std=c11`, `-std=c17`。
- **MSVC**: 默认模式不完全符合ISO C标准。需使用 `/std:c11` 或 `/std:c17` 编译选项，才会正确定义 `__STDC__` 和 `__STDC_VERSION__` 宏。

### 2. 版本检测代码示例
可嵌入以下代码检测编译器支持的标准：

```c
    #include <stdio.h>

    int What_Standard() {
    #ifdef __STDC__
        printf("此编译器支持ANSI C标准。\n");
        printf("__STDC__ 被定义为：%d\n", __STDC__);
    #ifdef __STDC_VERSION__
        printf("C语言标准版本：%ld\n", __STDC_VERSION__);
    #if __STDC_VERSION__ >= 201710L
        printf("支持C17或更高版本。\n");
    #elif __STDC_VERSION__ >= 201112L
        printf("支持C11标准。\n");
    #elif __STDC_VERSION__ >= 199901L
        printf("支持C99标准。\n");
    #else
        printf("支持C89/C90标准。\n");
    #endif
    #else
        printf("支持C89/C90标准。\n");
    #endif
    #else
        printf("此编译器可能不完全支持ANSI C标准。\n");
    #endif
        return 0;
    }
```
