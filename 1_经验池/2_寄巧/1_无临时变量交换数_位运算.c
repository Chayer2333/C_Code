#include<stdio.h>
int main()
{
	int a,b;
	printf("请输入两个树：");
	scanf("%d%d",&a,&b);
	a^=b;b^=a;a^=b; //位运算交换通常使用异或（XOR）操作，因为异或的性质使得两个变量可以在不使用临时变量的情况下交换值
	printf("\n%d,%d",a,b); 
}


/*
	*p^=*(p+1);  // 步骤 1：a = a ^ b (存储差异信息)
	*(p+1)^=*p;  // 步骤 2：b = b ^ a (相当于原始 a值)
	*p^=*(p+1);  // 步骤 3：a = a ^ b (相当于原始 b值)
	
	
通过三次异或操作实现无临时变量的数据交换，利用了异或运算的以下特性：

x ^ x = 0

x ^ 0 = x

可逆性：(x ^ y) ^ y = x

安全边界：

由于操作的是相邻元素（*p和*(p+1)），不存在地址重叠风险

异或交换不依赖数值正负，适用于所有整型数据


注意事项：

该算法仅适用于整型数据（int/long等）

当操作相同内存地址时（如尝试交换 *p 与 *p），异或交换会清空数据（x^x=0）

现代编译器可能对这类技巧优化有限，实际工程中建议使用常规交换方式以保证可读性

这个版本在保持原算法时间复杂度（O(n2)）和空间复杂度（O(1)）的同时，通过位运算实现了更底层的数值操作。

*/
